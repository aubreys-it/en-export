
name: build-push-deploy-aca (Az)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  RG: rg-en-export
  ENV: enexport-aca-env
  APP: enexport-app
  ACR_NAME: enexportacr123

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write      # required for OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Login to Azure using OIDC; enables Az cmdlets in subsequent steps
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true   # prepares Az PowerShell session for later steps

      - name: Get ACR login server (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            "loginServer=$($acr.LoginServer)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: ACR login for Docker (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            Connect-AzContainerRegistry -Name $env:ACR_NAME
      # Connect-AzContainerRegistry sets Docker creds to push/pull. [1](https://dev.to/latzo/automating-azure-project-setup-with-powershell-and-github-actions-572f)

      - name: Build & Push image (single-step version)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            $loginServer = $acr.LoginServer
            $tag = (Get-Date -Format 'yyyyMMdd-HHmm')
            $image = "$loginServer/en-export-func:$tag"
            Write-Host "Building $image"
            docker build -t "$image" .
            docker push "$image"
            "IMAGE=$image" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            "ACR_SERVER=$loginServer" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Update image via ARM PATCH (az rest)
        shell: bash
        env:
          SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail

          APP="${APP:?APP env is required}"
          RG="${RG:?RG env is required}"
          IMAGE="${IMAGE:?IMAGE env is required}"

          az account set --subscription "$SUBSCRIPTION_ID"

          # Build the ARM URL (Container Apps Update endpoint)
          API="2023-05-01"
          APP_ID=$(az containerapp show -n "$APP" -g "$RG" --query id -o tsv)
          URL="https://management.azure.com${APP_ID}?api-version=${API}"

          # Container name must match your template (you use "main")
          CONTAINER_NAME="main"

          # Minimal JSON Merge Patch body (only change the image)
          BODY=$(jq -n --arg img "$IMAGE" --arg name "$CONTAINER_NAME" \
            '{properties:{template:{containers:[{name:$name,image:$img}]}}}')

          echo "PATCHing $URL to image $IMAGE"
          az rest --method patch --url "$URL" --body "$BODY" --headers "Content-Type=application/json"

          # Verify the template reflects the new image immediately
          CURR=$(az containerapp show -n "$APP" -g "$RG" --query properties.template.containers[0].image -o tsv || true)
          echo "Template image after PATCH: ${CURR:-<none>}"
          if [ "$CURR" != "$IMAGE" ]; then
            echo "WARNING: Template image not updated yet; the wait step will check again."
          fi

      - name: Upgrade Container Apps CLI
        shell: bash
        run: |
          set -euo pipefail
          az upgrade -y || true
          az extension add -n containerapp --upgrade -y || true

          
      # Re-issue the PATCH using the latest API (idempotent) and capture previous revision
      - name: Ensure image is patched via ARM (latest API)
        shell: bash
        env:
          SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail
          az account set --subscription "$SUBSCRIPTION_ID"

          API="2025-07-01" # latest documented Container Apps Update API
          APP_ID=$(az containerapp show -n "$APP" -g "$RG" --query id -o tsv)
          URL="https://management.azure.com${APP_ID}?api-version=${API}"

          PREV_REV=$(az containerapp show -n "$APP" -g "$RG" --query properties.latestRevisionName -o tsv || echo "")
          echo "PREV_REV=$PREV_REV" >> $GITHUB_ENV

          # PATCH just the image (JSON Merge Patch)
          BODY=$(jq -n --arg img "$IMAGE" --arg name "main" \
            '{properties:{template:{containers:[{name:$name,image:$img}]}}}')
          az rest --method patch --url "$URL" \
            --headers "Content-Type=application/json" \
            --body "$BODY" --output none

            
      # Robust wait: confirm template updates, then find the matching revision, then wait on its health
      - name: Wait for image to apply and revision to become Healthy
        shell: bash
        run: |
          set -euo pipefail

          TARGET_IMG="$IMAGE"
          echo "üîé Target image: $TARGET_IMG"

          # 1) Wait for the app template to reflect the target image (eventual consistency)
          MAX_TRIES=24  # ~2m @5s
          SLEEP=5
          TEMPLATE_OK=""
          for i in $(seq 1 $MAX_TRIES); do
            CUR_IMG=$(az containerapp show -n "$APP" -g "$RG" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || echo "")
            APP_STATE=$(az containerapp show -n "$APP" -g "$RG" --query "properties.provisioningState" -o tsv 2>/dev/null || echo "")
            echo "Template check $i/$MAX_TRIES: image='$CUR_IMG' | app.provisioningState='$APP_STATE'"
            if [[ "$CUR_IMG" == "$TARGET_IMG" ]]; then
              TEMPLATE_OK="yes"; break
            fi
            sleep $SLEEP
          done

          # If still not reflected, retry PATCH once (handles missed write/race) and wait again quickly
          if [[ -z "$TEMPLATE_OK" ]]; then
            echo "‚ö†Ô∏è Template hasn't reflected image yet. Re-issuing PATCH once."
            API="2025-07-01"
            APP_ID=$(az containerapp show -n "$APP" -g "$RG" --query id -o tsv)
            URL="https://management.azure.com${APP_ID}?api-version=${API}"
            BODY=$(jq -n --arg img "$TARGET_IMG" --arg name "main" \
              '{properties:{template:{containers:[{name:$name,image:$img}]}}}')
            az rest --method patch --url "$URL" \
              --headers "Content-Type=application/json" \
              --body "$BODY" --output none
            for i in $(seq 1 12); do
              CUR_IMG=$(az containerapp show -n "$APP" -g "$RG" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || echo "")
              echo "Re-check template ($i/12): '$CUR_IMG'"
              [[ "$CUR_IMG" == "$TARGET_IMG" ]] && { TEMPLATE_OK="yes"; break; }
              sleep 5
            done
          fi

          if [[ -z "$TEMPLATE_OK" ]]; then
            echo "‚ùå Template never reflected target image '$TARGET_IMG'."
            echo "Dumping app JSON for context:"
            az containerapp show -n "$APP" -g "$RG" -o jsonc || true
            exit 1
          fi

          # 2) Find the new revision that references the target image
          #    We cannot rely on app.provisioningState; we must find and wait on the revision itself.
          #    (CLI docs: 'az containerapp revision list/show') 
          #    NOTE: list returns newest first in most cases; filter by image to be precise.
          TARGET_REV=""
          for i in $(seq 1 60); do
            TARGET_REV=$(az containerapp revision list -n "$APP" -g "$RG" \
              --query "[?properties.template.containers[0].image=='${TARGET_IMG}']|[0].name" -o tsv 2>/dev/null || echo "")
            if [[ -n "$TARGET_REV" ]]; then
              echo "‚úÖ Found target revision: $TARGET_REV"
              break
            fi
            echo "‚è≥ Waiting for target revision to appear ($i/60)..."
            sleep 5
          done

          if [[ -z "$TARGET_REV" ]]; then
            echo "‚ùå No revision found with image '$TARGET_IMG'. Revisions snapshot:"
            az containerapp revision list -n "$APP" -g "$RG" -o table || true
            exit 1
          fi

          # 3) Wait for the revision to be Ready / Healthy
          #    We check provisioningState, healthState and runningState.
          #    If it fails, dump logs to help diagnose (pull errors, probe failures, etc).
          MAX_TRIES=90  # up to ~7.5m @5s
          SLEEP=5
          READY=""
          for i in $(seq 1 $MAX_TRIES); do
            REV_JSON=$(az containerapp revision show -n "$APP" -g "$RG" --revision "$TARGET_REV" -o json 2>/dev/null || echo "{}")
            PROV=$(echo "$REV_JSON" | jq -r '.properties.provisioningState // empty')
            HEALTH=$(echo "$REV_JSON" | jq -r '.properties.healthState // empty')
            RUNSTATE=$(echo "$REV_JSON" | jq -r '.properties.runningState // empty')

            echo "Revision $TARGET_REV status ($i/$MAX_TRIES): provisioning=$PROV | health=$HEALTH | runningState=$RUNSTATE"

            if [[ "$PROV" == "Succeeded" && "$HEALTH" == "Healthy" && "$RUNSTATE" =~ ^(Running|RunningAtMaxScale)$ ]]; then
              READY="yes"; break
            fi

            # Immediate failure path
            if [[ "$PROV" == "Failed" || "$HEALTH" =~ ^(Failed|Degraded)$ ]]; then
              echo "‚ùå Revision indicates failure. Fetching logs‚Ä¶"
              az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --type system --tail 200 --format text || true
              az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --tail 200 --format text || true
              echo "Revisions snapshot:"
              az containerapp revision list -n "$APP" -g "$RG" -o table || true
              exit 1
            fi

            sleep $SLEEP
          done

          if [[ -z "$READY" ]]; then
            echo "‚ùå Timed out waiting for revision $TARGET_REV to become Healthy."
            echo "Dumping recent logs to help diagnose:"
            az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --type system --tail 200 --format text || true
            az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --tail 200 --format text || true
            exit 1
          fi

          # 4) In Single revision mode, confirm the latestReadyRevisionName matches the target 
          LATEST_READY=$(az containerapp show -n "$APP" -g "$RG" --query properties.latestReadyRevisionName -o tsv || echo "")
          echo "latestReadyRevisionName: $LATEST_READY"
          if [[ -n "$LATEST_READY" && "$LATEST_READY" != "$TARGET_REV" ]]; then
            echo "‚ö†Ô∏è App has a different latestReadyRevisionName ($LATEST_READY) than target ($TARGET_REV)."
            echo "Traffic may still be switching; continuing since target is Healthy."
          fi

          echo "‚úÖ Deployment succeeded: $TARGET_REV is Healthy and running."


      