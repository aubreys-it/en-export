
name: build-push-deploy-aca (Az)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  RG: rg-en-export
  ENV: enexport-aca-env
  APP: enexport-app
  ACR_NAME: enexportacr123

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write      # required for OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Login to Azure using OIDC; enables Az cmdlets in subsequent steps
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true   # prepares Az PowerShell session for later steps

      - name: Get ACR login server (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            "loginServer=$($acr.LoginServer)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: ACR login for Docker (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            Connect-AzContainerRegistry -Name $env:ACR_NAME
      # Connect-AzContainerRegistry sets Docker creds to push/pull. [1](https://dev.to/latzo/automating-azure-project-setup-with-powershell-and-github-actions-572f)

      - name: Build & Push image (single-step version)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            $loginServer = $acr.LoginServer
            $tag = (Get-Date -Format 'yyyyMMdd-HHmm')
            $image = "$loginServer/en-export-func:$tag"
            Write-Host "Building $image"
            docker build -t "$image" .
            docker push "$image"
            "IMAGE=$image" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            "ACR_SERVER=$loginServer" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
      
      #- name: Build & Push image (Docker)
      #  run: |
      #    TAG=$(date +'%Y%m%d-%H%M')
      #    IMAGE="${{ steps.get_acr_login_server.outputs.loginServer }}/en-export-func:${TAG}"
      #    docker build -t "$IMAGE" .
      #    docker push "$IMAGE"
      #    echo "IMAGE=$IMAGE" >> $GITHUB_ENV
      #  id: build_push
      #  env:
      #    get_acr_login_server: ${{ steps.Get_ACR_login_server.outputs.loginServer }}

      # (Optional) Ensure Dapr Cron component is present/up-to-date (scoped to $APP)
      # Requires cron-dapr.yaml in repo; comment out if you manage this outside CI.
      # - name: Set/Update Dapr Cron component (Az REST optional)
      #   uses: azure/powershell@v1
      #   with:
      #     azPSVersion: "10.0"
      #     inlineScript: |
      #       # Example: use ARM template or Invoke-AzRest to put the dapr component.
      #       # Dapr components are environment resources; 'scopes' should include $env:APP. [3](https://github.com/Azure/azure-cli/issues/25829)
      #       Write-Host "Skipping cron component enforcement in this run."

      #- name: Update ACA app to new image (ARM + Az PowerShell)
      #  uses: azure/powershell@v1
      #  with:
      #    azPSVersion: "10.0"
      #    inlineScript: |
      #      New-AzResourceGroupDeployment `
      #        -ResourceGroupName $env:RG `
      #        -TemplateFile ./aca-app.json `
      #        -envName $env:ENV `
      #        -appName $env:APP `
      #        -image $env:IMAGE `
      #        -acrServer $env:ACR_SERVER `
      #        -ingress "internal"
      
      - name: Update image via ARM PUT (Az REST)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            if (-not $env:IMAGE) { throw "IMAGE is not set." }
            $sub = (Get-AzContext).Subscription.Id
            $rid = "/subscriptions/$sub/resourceGroups/$env:RG/providers/Microsoft.App/containerApps/$env:APP?api-version=2023-05-01"

            # GET current app
            $app = (Invoke-AzRest -Method GET -Path $rid).Content | ConvertFrom-Json

            # (Optional) ensure registries and MI identity are present if your template doesnâ€™t set them
            # $app.identity.type = "SystemAssigned" # only if it wasn't set by template

            # Update the image
            $app.properties.template.containers[0].image = $env:IMAGE
            $body = $app | ConvertTo-Json -Depth 100

            Write-Host "Updating Container App with image $($env:IMAGE)"
            $resp = Invoke-AzRest -Method PUT -Path $rid -Payload $body
            if ($resp.StatusCode -notin 200,201,202) { throw "Failed to update app: $($resp.Content)" }

      - name: Wait for revision to become Ready
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $sub = (Get-AzContext).Subscription.Id
            $rid = "/subscriptions/$sub/resourceGroups/$env:RG/providers/Microsoft.App/containerApps/$env:APP?api-version=2023-05-01"

            $deadline = (Get-Date).AddMinutes(10)  # adjust if your image is big
            do {
              Start-Sleep -Seconds 10
              $app = (Invoke-AzRest -Method GET -Path $rid).Content | ConvertFrom-Json
              $rev = $app.properties.latestRevisionName
              $activeRevisions = $app.properties.revisions | Where-Object { $_.name -eq $rev }
              $state = $activeRevisions.properties.active ? $activeRevisions.properties.provisioningState : "Provisioning"
              Write-Host "Latest Revision: $rev  State: $state"
              if ((Get-Date) -gt $deadline) { throw "Timeout waiting for revision to become Ready." }
            } while ($state -ne "Succeeded")
