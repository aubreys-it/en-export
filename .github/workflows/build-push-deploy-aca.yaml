
name: build-push-deploy-aca (Az)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  RG: rg-en-export
  ENV: enexport-aca-env
  APP: enexport-app
  ACR_NAME: enexportacr123

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write      # required for OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Login to Azure using OIDC; enables Az cmdlets in subsequent steps
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true   # prepares Az PowerShell session for later steps

      - name: Get ACR login server (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            "loginServer=$($acr.LoginServer)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: ACR login for Docker (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            Connect-AzContainerRegistry -Name $env:ACR_NAME
      # Connect-AzContainerRegistry sets Docker creds to push/pull. [1](https://dev.to/latzo/automating-azure-project-setup-with-powershell-and-github-actions-572f)

      - name: Build & Push image (single-step version)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            $loginServer = $acr.LoginServer
            $tag = (Get-Date -Format 'yyyyMMdd-HHmm')
            $image = "$loginServer/en-export-func:$tag"
            Write-Host "Building $image"
            docker build -t "$image" .
            docker push "$image"
            "IMAGE=$image" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            "ACR_SERVER=$loginServer" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
      
      - name: Update image via ARM PATCH (token + Invoke-RestMethod, environment-aware)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $ErrorActionPreference = "Stop"

            if (-not $env:IMAGE) { throw "IMAGE is not set." }
            if (-not $env:RG)    { throw "RG is not set." }
            if (-not $env:APP)   { throw "APP is not set." }

            # Ensure subscription context
            $ctx = Get-AzContext
            $sub = $ctx.Subscription.Id
            if ([string]::IsNullOrWhiteSpace($sub)) { $sub = $env:AZURE_SUBSCRIPTION_ID }
            if ([string]::IsNullOrWhiteSpace($sub)) { throw "Subscription Id is not available." }
            Select-AzSubscription -SubscriptionId $sub | Out-Null

            # ARM base (public cloud example -> management.azure.com)
            $armBase = (Get-AzEnvironment -Name $ctx.Environment.Name).ResourceManagerUrl.TrimEnd('/')

            $apiVersion   = "2023-05-01"
            $resourcePath = "/subscriptions/$sub/resourceGroups/$($env:RG)/providers/Microsoft.App/containerApps/$($env:APP)"

            # Build URI
            $ub = [System.UriBuilder]::new("$armBase$resourcePath")
            $ub.Query = "api-version=$apiVersion"
            $uri = $ub.Uri.AbsoluteUri

            # Read app to get its location (required by PATCH schema)
            $appGetToken = (Get-AzAccessToken -ResourceUrl $armBase).Token
            $appHeaders  = @{ "Authorization" = "Bearer $appGetToken" }
            $appDoc      = Invoke-RestMethod -Method GET -Uri $uri -Headers $appHeaders -ErrorAction Stop
            $location    = $appDoc.location
            if ([string]::IsNullOrWhiteSpace($location)) { throw "Could not read app location; PATCH requires 'location'." }

            Write-Host "ARM Base: $armBase"
            Write-Host "SUB     : $sub"
            Write-Host "URI     : $uri"
            Write-Host "PATCHing image: $($env:IMAGE) with location: $location"

            $containerName = "main"   # from your aca-app.json

            # *** IMPORTANT: include 'location' in the PATCH body ***
            $body = @{
              location   = $location
              properties = @{
                template = @{
                  containers = @(
                    @{ name = $containerName; image = $env:IMAGE }
                  )
                }
              }
            } | ConvertTo-Json -Depth 100

            # Try current cloud audience, then fall back to core.windows.net if needed
            function Invoke-ArmPatch {
              param([string]$audienceBase)
              $token = (Get-AzAccessToken -ResourceUrl $audienceBase).Token
              $headers = @{ "Authorization" = "Bearer $token" }
              try {
                Invoke-RestMethod -Method PATCH -Uri $uri -Headers $headers -ContentType 'application/json' -Body $body -ErrorAction Stop | Out-Null
                return $true
              } catch {
                Write-Warning ("PATCH failed (" + $audienceBase + "): " + $_.Exception.Message)
                return $false
              }
            }

            $ok = Invoke-ArmPatch -audienceBase $armBase
            if (-not $ok) { $ok = Invoke-ArmPatch -audienceBase "https://management.core.windows.net/" }
            if (-not $ok) { throw "PATCH failed with both ARM audiences." }

      - name: Wait for image to be applied and app to become Ready (Azure CLI)
        shell: bash
        env:
          SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail

          APP="${APP:?APP env is required}"
          RG="${RG:?RG env is required}"
          DESIRED_IMAGE="${IMAGE:?IMAGE env is required}"

          az account set --subscription "$SUBSCRIPTION_ID"

          echo "Target image: $DESIRED_IMAGE"
          echo "Verifying the app reflects the target image in its template..."

          # --- Phase 1: Wait until the app template shows the desired image ---
          DEADLINE_IMAGE=$((SECONDS + 300))  # 5 minutes max to see image applied
          while true; do
            CURRENT_IMAGE="$(az containerapp show -n "$APP" -g "$RG" --query properties.template.containers[0].image -o tsv || true)"
            PS="$(az containerapp show -n "$APP" -g "$RG" --query properties.provisioningState -o tsv || true)"
            echo "Current template image: ${CURRENT_IMAGE:-<none>} | provisioningState=${PS:-<unknown>}"

            if [ "$CURRENT_IMAGE" = "$DESIRED_IMAGE" ]; then
              echo "The desired image is now in the app template."
              break
            fi

            if [ "$PS" = "Failed" ] && [ $SECONDS -gt $((DEADLINE_IMAGE - 240)) ]; then
              # If we already see Failed and we are well into the wait, fail faster with diagnostics
              echo "ERROR: App provisioningState=Failed while waiting for image to apply."
              az containerapp show -n "$APP" -g "$RG" -o json || true
              exit 1
            fi

            if [ $SECONDS -gt $DEADLINE_IMAGE ]; then
              echo "ERROR: Timed out waiting for template image to become $DESIRED_IMAGE."
              echo "App (raw):"
              az containerapp show -n "$APP" -g "$RG" -o json || true
              exit 1
            fi

            sleep 5
          done

          # --- Phase 2: Wait for app to return to a healthy state or a ready revision to appear ---
          echo "Waiting for the app to become Ready (Succeeded) or to expose a ready revision..."

          DEADLINE_READY=$((SECONDS + 600))  # 10 minutes
          while true; do
            PS="$(az containerapp show -n "$APP" -g "$RG" --query properties.provisioningState -o tsv || true)"
            LRN="$(az containerapp show -n "$APP" -g "$RG" --query properties.latestReadyRevisionName -o tsv || true)"
            LSN="$(az containerapp show -n "$APP" -g "$RG" --query properties.latestRevisionName -o tsv || true)"

            echo "provisioningState=${PS:-<unknown>} | latestReadyRevisionName=${LRN:-<none>} | latestRevisionName=${LSN:-<none>}"

            if [ "$PS" = "Succeeded" ] || [ -n "$LRN" ] && [ "$LRN" != "None" ]; then
              echo "App is Ready."
              break
            fi

            # As a fallback, if a revision exists, check its provisioningState
            REV="$(az containerapp revision list -n "$APP" -g "$RG" \
                  --query "max_by([].{n:name, t:properties.createdTime}, &t).n" -o tsv || true)"
            if [ -n "$REV" ] && [ "$REV" != "None" ]; then
              RSTATE="$(az containerapp revision show -n "$APP" -g "$RG" --revision "$REV" \
                      --query properties.provisioningState -o tsv || true)"
              echo "Newest revision ${REV} state: ${RSTATE:-<unknown>}"
              if [ "$RSTATE" = "Succeeded" ]; then
                echo "Newest revision is Ready."
                break
              fi
            fi

            if [ "$PS" = "Failed" ] && [ $SECONDS -gt $((DEADLINE_READY - 540)) ]; then
              echo "ERROR: App provisioningState=Failed during readiness wait. Dumping details:"
              az containerapp show -n "$APP" -g "$RG" -o json || true
              exit 1
            fi

            if [ $SECONDS -gt $DEADLINE_READY ]; then
              echo "ERROR: Timeout waiting for the app to become Ready."
              echo "App (raw):"
              az containerapp show -n "$APP" -g "$RG" -o json || true
              echo "Revisions (raw):"
              az containerapp revision list -n "$APP" -g "$RG" -o json || true
              exit 1
            fi

            sleep 10
          done