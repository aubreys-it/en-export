
name: build-push-deploy-aca (Az)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  RG: rg-en-export
  ENV: enexport-aca-env
  APP: enexport-app
  ACR_NAME: enexportacr123

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write      # required for OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Login to Azure using OIDC; enables Az cmdlets in subsequent steps
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true   # prepares Az PowerShell session for later steps

      - name: Get ACR login server (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            "loginServer=$($acr.LoginServer)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: ACR login for Docker (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            Connect-AzContainerRegistry -Name $env:ACR_NAME
      # Connect-AzContainerRegistry sets Docker creds to push/pull. [1](https://dev.to/latzo/automating-azure-project-setup-with-powershell-and-github-actions-572f)

      - name: Build & Push image (single-step version)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            $loginServer = $acr.LoginServer
            $tag = (Get-Date -Format 'yyyyMMdd-HHmm')
            $image = "$loginServer/en-export-func:$tag"
            Write-Host "Building $image"
            docker build -t "$image" .
            docker push "$image"
            "IMAGE=$image" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            "ACR_SERVER=$loginServer" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
      
      - name: Update image via ARM PATCH (token + Invoke-RestMethod w/ audience fallback)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $ErrorActionPreference = "Stop"

            if (-not $env:IMAGE) { throw "IMAGE is not set." }
            if (-not $env:RG)    { throw "RG is not set." }
            if (-not $env:APP)   { throw "APP is not set." }

            # Ensure the right subscription context
            $sub = (Get-AzContext).Subscription.Id
            if ([string]::IsNullOrWhiteSpace($sub)) { $sub = $env:AZURE_SUBSCRIPTION_ID }
            if ([string]::IsNullOrWhiteSpace($sub)) { throw "Subscription Id is not available in the Az context." }
            Select-AzSubscription -SubscriptionId $sub | Out-Null

            $apiVersion   = "2023-05-01"
            $resourcePath = "/subscriptions/$sub/resourceGroups/$($env:RG)/providers/Microsoft.App/containerApps/$($env:APP)"

            # Build URI safely
            $ub = [System.UriBuilder]::new("https://management.azure.com$resourcePath")
      
      - name: Wait for revision to become Ready (same auth as PATCH + fallback to list)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $ErrorActionPreference = "Stop"

            if (-not $env:RG)  { throw "RG is not set." }
            if (-not $env:APP) { throw "APP is not set." }

            # 1) Subscription & environment-aware ARM base (same as PATCH step)
            $ctx = Get-AzContext
            $sub = $ctx.Subscription.Id
            if ([string]::IsNullOrWhiteSpace($sub)) { $sub = $env:AZURE_SUBSCRIPTION_ID }
            if ([string]::IsNullOrWhiteSpace($sub)) { throw "Subscription Id is not available." }
            Select-AzSubscription -SubscriptionId $sub | Out-Null

            $armBase   = (Get-AzEnvironment -Name $ctx.Environment.Name).ResourceManagerUrl.TrimEnd('/')
            $api       = "2023-05-01"
            $appPath   = "/subscriptions/$sub/resourceGroups/$($env:RG)/providers/Microsoft.App/containerApps/$($env:APP)"
            $listPath  = "$appPath/revisions"

            function New-ArmUri([string]$base, [string]$path, [string]$api) {
              $ub = [System.UriBuilder]::new("$base$path")
              $ub.Query = "api-version=$api"
              $ub.Uri.AbsoluteUri
            }

            function Get-ArmJson {
              param([string]$audienceBase, [string]$url)
              try {
                $token = (Get-AzAccessToken -ResourceUrl $audienceBase).Token
                if ([string]::IsNullOrWhiteSpace($token)) { throw "No token for $audienceBase" }
                $headers = @{ "Authorization" = "Bearer $token" }
                return Invoke-RestMethod -Method GET -Uri $url -Headers $headers -ErrorAction Stop
              } catch {
                Write-Warning ("GET failed (" + $audienceBase + "): " + $_.Exception.Message)
                return $null
              }
            }

            # Helper that tries current cloud ARM base then classic core.windows.net
            function Get-ArmJsonWithFallback([string]$url) {
              $res = Get-ArmJson -audienceBase $armBase -url $url
              if ($null -eq $res) { $res = Get-ArmJson -audienceBase "https://management.core.windows.net/" -url $url }
              return $res
            }

            # Small settle delay after PATCH helps in practice
            Start-Sleep -Seconds 5

            # 2) Try to read latestRevisionName from the app
            $appUri = New-ArmUri -base $armBase -path $appPath -api $api
            $app = Get-ArmJsonWithFallback $appUri
            if ($null -eq $app) { throw "GET app failed for all ARM audiences." }

            $revName = $app.properties.latestRevisionName

            # 3) Fallback: if latestRevisionName is empty, list revisions and pick newest
            if ([string]::IsNullOrWhiteSpace($revName)) {
              Write-Host "latestRevisionName empty; falling back to revisions listâ€¦"
              $listUri = New-ArmUri -base $armBase -path $listPath -api $api
              $list = Get-ArmJsonWithFallback $listUri
              if ($null -eq $list -or -not $list.value) { throw "Revisions list empty or unavailable." }

              # Sort by createdTime descending (if present); otherwise keep order
              $items = $list.value
              if ($items[0].properties.PSObject.Properties.Name -contains "createdTime") {
                $items = $items | Sort-Object { [datetime]$_.properties.createdTime } -Descending
              }
              $revName = $items[0].name
              if ([string]::IsNullOrWhiteSpace($revName)) { throw "Unable to resolve latest revision name from list." }
              Write-Host "Picked latest revision from list: $revName"
            } else {
              Write-Host "Latest revision reported by app: $revName"
            }

            # 4) Poll the specific revision until provisioningState == Succeeded
            $revPath = "$appPath/revisions/$revName"
            $revUri  = New-ArmUri -base $armBase -path $revPath -api $api

            $deadline = (Get-Date).AddMinutes(10)  # increase if your image is big
            do {
              Start-Sleep -Seconds 10
              $rev = Get-ArmJsonWithFallback $revUri
              if ($null -eq $rev) { throw "GET revision failed for all ARM audiences during polling." }

              $state = $rev.properties.provisioningState
              Write-Host "Revision $revName  State: $state"

              if ((Get-Date) -gt $deadline) { throw "Timeout waiting for the new revision to become Ready." }
            } while ($state -ne "Succeeded")