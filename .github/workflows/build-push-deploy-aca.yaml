
name: Build, Push & Deploy to Azure Container Apps

on:
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  id-token: write       # required for azure/login OIDC
  contents: read

concurrency:
  group: aca-enexport
  cancel-in-progress: false

env:
  # ----- Azure resource identifiers (update if needed) -----
  RG: rg-en-export
  APP: enexport-app
  ACR_NAME: enexportacr123                  # ACR resource name (no domain)
  ACR_REGISTRY: enexportacr123.azurecr.io   # ACR login server (domain)
  IMAGE_NAME: en-export-func                 # repo name in ACR
  # ---------------------------------------------------------
  # Build tag format: UTC timestamp (e.g., 20260122-2016)
  TZ: UTC

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Upgrade Azure CLI bits (optional but recommended)
        shell: bash
        run: |
          set -euo pipefail
          az upgrade -y || true
          az extension add -n containerapp --upgrade -y || true

      - name: Create build tag
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          TAG="$(date -u +%Y%m%d-%H%M)"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "TAG=$TAG" >> "$GITHUB_ENV"
          echo "IMAGE=${{ env.ACR_REGISTRY }}/${{ env.IMAGE_NAME }}:$TAG" >> "$GITHUB_ENV"
          echo "Using tag: $TAG"

      - name: Docker build & push to ACR
        shell: bash
        run: |
          set -euo pipefail
          echo "üîß Building image: $IMAGE"
          docker build \
                -f ./src/en-export-app/Dockerfile \
                -t "$IMAGE" \
                ./src/en-export-app

          echo "üîê Logging into ACR: $ACR_NAME"
          az acr login -n "$ACR_NAME"
          echo "‚è´ Pushing image: $IMAGE"
          docker push "$IMAGE"

      # ---- New: wait for ACR to acknowledge the tag to avoid MANIFEST_UNKNOWN ----
      - name: Wait for ACR tag to exist
        shell: bash
        run: |
          set -euo pipefail
          TARGET="$IMAGE"                                   # e.g. enexportacr123.azurecr.io/en-export-func:20260122-2016
          REG_HOST="${TARGET%%/*}"                          # enexportacr123.azurecr.io
          REMAIN="${TARGET#*/}"                             # en-export-func:20260122-2016
          REPO="${REMAIN%%:*}"                              # en-export-func
          TAG="${REMAIN##*:}"                               # 20260122-2016
          ACR="${REG_HOST%%.*}"                             # enexportacr123
          echo "üîé Waiting for ACR image to be available: ${REG_HOST}/${REPO}:${TAG}"

          MAX_TRIES=60
          SLEEP=5
          for i in $(seq 1 $MAX_TRIES); do
            if az acr manifest show -r "$ACR" -n "${REPO}:${TAG}" >/dev/null 2>&1; then
              echo "‚úÖ Tag present in ACR."
              exit 0
            fi
            # Fallback for older CLIs using show-tags
            if az acr repository show-tags -n "$ACR" --repository "$REPO" --query "contains(@, '${TAG}')" -o tsv 2>/dev/null | grep -qi true; then
              echo "‚úÖ Tag present (via show-tags)."
              exit 0
            fi
            echo "‚è≥ Tag not present yet ($i/$MAX_TRIES). Sleeping ${SLEEP}s..."
            sleep $SLEEP
          done

          echo "‚ùå Timed out waiting for ${REPO}:${TAG} in ACR '${ACR}'."
          exit 1

      # ---- PATCH the Container App to use the new image (idempotent) ----
      - name: Update image via ARM PATCH
        shell: bash
        env:
          SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail
          az account set --subscription "$SUBSCRIPTION_ID"

          API="2025-07-01"
          APP_ID=$(az containerapp show -n "$APP" -g "$RG" --query id -o tsv)
          URL="https://management.azure.com${APP_ID}?api-version=${API}"

          echo "üîÅ Patching $APP to image: $IMAGE"
          BODY=$(jq -n --arg img "$IMAGE" --arg name "main" \
            '{properties:{template:{containers:[{name:$name,image:$img}]}}}')
          az rest --method patch --url "$URL" \
            --headers "Content-Type=application/json" \
            --body "$BODY" --output none

      # ---- Wait for new revision with this image to become Healthy ----
      - name: Wait for image to apply and revision to become Healthy
        shell: bash
        run: |
          set -euo pipefail

          TARGET_IMG="$IMAGE"
          echo "üéØ Target image: $TARGET_IMG"

          # 1) Short wait for template to reflect the image (eventual consistency)
          for i in $(seq 1 18); do
            CUR_IMG=$(az containerapp show -n "$APP" -g "$RG" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || echo "")
            APP_STATE=$(az containerapp show -n "$APP" -g "$RG" --query "properties.provisioningState" -o tsv 2>/dev/null || echo "")
            echo "üß© Template check $i/18: image='$CUR_IMG' | app.provisioningState='$APP_STATE'"

            [[ "$CUR_IMG" == "$TARGET_IMG" ]] && break

            if [[ "$APP_STATE" == "Failed" ]]; then
              echo "‚ö†Ô∏è App provisioningState=Failed; deploymentErrors:"
              az containerapp show -n "$APP" -g "$RG" --query properties.deploymentErrors -o tsv || true
            fi
            sleep 5
          done

          # 2) Find the target revision that references the new image
          TARGET_REV=""
          for i in $(seq 1 60); do
            TARGET_REV=$(az containerapp revision list -n "$APP" -g "$RG" \
              --query "[?properties.template.containers[0].image=='${TARGET_IMG}']|[0].name" -o tsv 2>/dev/null || echo "")
            [[ -n "$TARGET_REV" ]] && { echo "‚úÖ Target revision detected: $TARGET_REV"; break; }
            echo "‚è≥ Waiting for target revision to appear ($i/60)‚Ä¶"
            sleep 5
          done

          if [[ -z "$TARGET_REV" ]]; then
            echo "‚ùå No revision found with image '$TARGET_IMG'. Revisions snapshot:"
            az containerapp revision list -n "$APP" -g "$RG" -o table || true
            exit 1
          fi

          # 3) Wait for revision to be Ready/Healthy/Running
          MAX_TRIES=90
          for i in $(seq 1 $MAX_TRIES); do
            REV_JSON=$(az containerapp revision show -n "$APP" -g "$RG" --revision "$TARGET_REV" -o json 2>/dev/null || echo "{}")
            PROV=$(echo "$REV_JSON" | jq -r '.properties.provisioningState // empty')
            HEALTH=$(echo "$REV_JSON" | jq -r '.properties.healthState // empty')
            RUNSTATE=$(echo "$REV_JSON" | jq -r '.properties.runningState // empty')
            echo "üìà Revision $TARGET_REV ($i/$MAX_TRIES): provisioning=$PROV | health=$HEALTH | runningState=$RUNSTATE"

            if [[ "$PROV" == "Provisioned" && "$HEALTH" == "Healthy" && "$RUNSTATE" =~ ^(Running|RunningAtMaxScale)$ ]]; then
              echo "‚úÖ Deployment succeeded: $TARGET_REV is Healthy and running."
              exit 0
            fi

            if [[ "$PROV" == "Failed" || "$HEALTH" =~ ^(Failed|Degraded)$ ]]; then
              echo "‚ùå Revision indicates failure. Recent system + console logs:"
              az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --type system --tail 200 --format text || true
              az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --tail 200 --format text || true
              exit 1
            fi

            sleep 5
          done

          echo "‚ùå Timed out waiting for revision $TARGET_REV to become Healthy."
          echo "Dumping recent logs to help diagnose:"
          az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --type system --tail 200 --format text || true
          az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --tail 200 --format text || true
          exit 1
