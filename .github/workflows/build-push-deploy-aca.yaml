
name: build-push-deploy-aca (Az)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  RG: rg-en-export
  ENV: enexport-aca-env
  APP: enexport-app
  ACR_NAME: enexportacr123

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write      # required for OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Login to Azure using OIDC; enables Az cmdlets in subsequent steps
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true   # prepares Az PowerShell session for later steps

      - name: Get ACR login server (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            "loginServer=$($acr.LoginServer)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: ACR login for Docker (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            Connect-AzContainerRegistry -Name $env:ACR_NAME
      # Connect-AzContainerRegistry sets Docker creds to push/pull. [1](https://dev.to/latzo/automating-azure-project-setup-with-powershell-and-github-actions-572f)

      - name: Build & Push image (single-step version)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            $loginServer = $acr.LoginServer
            $tag = (Get-Date -Format 'yyyyMMdd-HHmm')
            $image = "$loginServer/en-export-func:$tag"
            Write-Host "Building $image"
            docker build -t "$image" .
            docker push "$image"
            "IMAGE=$image" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            "ACR_SERVER=$loginServer" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
      
      
      
      - name: Update image via ARM PATCH (token + Invoke-RestMethod)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $ErrorActionPreference = "Stop"

            if (-not $env:IMAGE) { throw "IMAGE is not set." }
            if (-not $env:RG)    { throw "RG is not set." }
            if (-not $env:APP)   { throw "APP is not set." }

            # Ensure subscription context (azure/login@v2 sets this)
            $sub = (Get-AzContext).Subscription.Id
            if ([string]::IsNullOrWhiteSpace($sub)) { $sub = $env:AZURE_SUBSCRIPTION_ID }
            if ([string]::IsNullOrWhiteSpace($sub)) { throw "Subscription Id is not available in the Az context." }

            $apiVersion = "2023-05-01"  # stable API for Container Apps (RM)
            $resourcePath = "/subscriptions/$sub/resourceGroups/$($env:RG)/providers/Microsoft.App/containerApps/$($env:APP)"

            # Build the full ARM URI safely
            $ub = [System.UriBuilder]::new("https://management.azure.com$resourcePath")
            $ub.Query = "api-version=$apiVersion"
            $uri = $ub.Uri.AbsoluteUri

            Write-Host "SUB:  $sub"
            Write-Host "PATH: $resourcePath"
            Write-Host "API : $apiVersion"
            Write-Host "PATCHing Container App with image $($env:IMAGE)"
            Write-Host "URI : $uri"

            # Acquire ARM token using Az
            $token = (Get-AzAccessToken -ResourceUrl "https://management.azure.com").Token

            # Container name from your aca-app.json
            $containerName = "main"

            # Minimal JSON Merge Patch body: only update the image
            $body = @{
              properties = @{
                template = @{
                  containers = @(
                    @{
                      name  = $containerName
                      image = $env:IMAGE
                    }
                  )
                }
              }
            } | ConvertTo-Json -Depth 100

            $headers = @{ "Authorization" = "Bearer $token" }
            $resp = Invoke-RestMethod -Method PATCH -Uri $uri -Headers $headers -ContentType 'application/json' -Body $body -ErrorAction Stop

            # Some PSGallery builds don’t populate StatusCode; do a GET to verify success
            Write-Host "PATCH submitted. Verifying with a GET…"
            $get = Invoke-RestMethod -Method GET -Uri $uri -Headers $headers -ErrorAction Stop
            if (-not $get.properties) { throw "PATCH verification failed: no properties returned." }

      
      
      - name: Wait for revision to become Ready
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $ErrorActionPreference = "Stop"

            if (-not $env:RG)  { throw "RG is not set." }
            if (-not $env:APP) { throw "APP is not set." }

            $sub = (Get-AzContext).Subscription.Id
            if ([string]::IsNullOrWhiteSpace($sub)) { $sub = $env:AZURE_SUBSCRIPTION_ID }
            if ([string]::IsNullOrWhiteSpace($sub)) { throw "Subscription Id is not available in the Az context." }

            $apiVersion = "2023-05-01"
            $resourcePath = "/subscriptions/$sub/resourceGroups/$($env:RG)/providers/Microsoft.App/containerApps/$($env:APP)"
            $ub = [System.UriBuilder]::new("https://management.azure.com$resourcePath")
            $ub.Query = "api-version=$apiVersion"
            $uri = $ub.Uri.AbsoluteUri

            $token = (Get-AzAccessToken -ResourceUrl "https://management.azure.com").Token
            $headers = @{ "Authorization" = "Bearer $token" }

            $deadline = (Get-Date).AddMinutes(10)  # bump for very large images
            do {
              Start-Sleep -Seconds 10
              $get = Invoke-RestMethod -Method GET -Uri $uri -Headers $headers -ErrorAction Stop
              $rev = $get.properties.latestRevisionName
              $activeRev = $get.properties.revisions | Where-Object { $_.name -eq $rev }
              $state = $activeRev.properties.provisioningState

              Write-Host "Latest Revision: $rev  State: $state"
              if ((Get-Date) -gt $deadline) { throw "Timeout waiting for the new revision to become Ready." }
            } while ($state -ne "Succeeded")


