
name: build-push-deploy-aca (Az)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  RG: rg-en-export
  ENV: enexport-aca-env
  APP: enexport-app
  ACR_NAME: enexportacr123

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write      # required for OIDC
      contents: read
      env:
        APP: enexport-app
        RG: rg-en-export
        IMAGE: enexportacr123.azurecr.io/en-export-func:${{ steps.meta.outputs.tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Login to Azure using OIDC; enables Az cmdlets in subsequent steps
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true   # prepares Az PowerShell session for later steps

      - name: Get ACR login server (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            "loginServer=$($acr.LoginServer)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: ACR login for Docker (Az PowerShell)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            Connect-AzContainerRegistry -Name $env:ACR_NAME
      # Connect-AzContainerRegistry sets Docker creds to push/pull. [1](https://dev.to/latzo/automating-azure-project-setup-with-powershell-and-github-actions-572f)

      - name: Build & Push image (single-step version)
        uses: azure/powershell@v1
        with:
          azPSVersion: "10.0"
          inlineScript: |
            $acr = Get-AzContainerRegistry -ResourceGroupName $env:RG -Name $env:ACR_NAME
            $loginServer = $acr.LoginServer
            $tag = (Get-Date -Format 'yyyyMMdd-HHmm')
            $image = "$loginServer/en-export-func:$tag"
            Write-Host "Building $image"
            docker build -t "$image" .
            docker push "$image"
            "IMAGE=$image" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            "ACR_SERVER=$loginServer" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Wait for ACR tag to exist
              shell: bash
              run: |
                set -euo pipefail
                TARGET="${IMAGE}"
                REG_HOST="${TARGET%%/*}"
                REMAIN="${TARGET#*/}"
                REPO="${REMAIN%%:*}"
                TAG="${REMAIN##*:}"
                ACR="${REG_HOST%%.*}"

                echo "üîé Waiting for ACR image: ${REG_HOST}/${REPO}:${TAG}"

                MAX_TRIES=60; SLEEP=5; FOUND=""
                for i in $(seq 1 $MAX_TRIES); do
                  if az acr manifest show -r "$ACR" -n "${REPO}:${TAG}" >/dev/null 2>&1; then
                    FOUND="yes"; echo "‚úÖ Tag is present in ACR."; break
                  fi
                  if az acr repository show-tags -n "$ACR" --repository "$REPO" --query "contains(@, '${TAG}')" -o tsv 2>/dev/null | grep -qi true; then
                    FOUND="yes"; echo "‚úÖ Tag is present (via show-tags)."; break
                  fi
                  echo "‚è≥ Tag not present yet ($i/60). Sleeping $SLEEP s..."
                  sleep $SLEEP
                done
                if [[ -z "$FOUND" ]]; then
                  echo "‚ùå Timed out waiting for ${REPO}:${TAG} in ACR '${ACR}'."
                  exit 1
                fi
            # (Why: avoids control-plane rejection with MANIFEST_UNKNOWN when the tag isn't there yet.)  
            # Ref: Microsoft guidance to verify tag exists before pull/deploy.  
            # Sources: MS docs on manifest-not-found & ACR tag listing. [1][2]

            # 3) PATCH the Container App to use the new image
            #    If you already PATCH elsewhere, REMOVE one of the duplicates and keep only one.

      
      - name: Update image via ARM PATCH (idempotent)
              shell: bash
              env:
                SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
              run: |
                set -euo pipefail
                az account set --subscription "$SUBSCRIPTION_ID"

                API="2025-07-01"
                APP_ID=$(az containerapp show -n "$APP" -g "$RG" --query id -o tsv)
                URL="https://management.azure.com${APP_ID}?api-version=${API}"
                BODY=$(jq -n --arg img "$IMAGE" --arg name "main" \
                  '{properties:{template:{containers:[{name:$name,image:$img}]}}}')
                az rest --method patch --url "$URL" \
                  --headers "Content-Type=application/json" \
                  --body "$BODY" --output none
            # Ref: Container Apps Update supports JSON Merge PATCH and may return 202 for async. [3]

      - name: Wait for image to apply and revision to become Healthy
              shell: bash
              run: |
                set -euo pipefail

                TARGET_IMG="$IMAGE"
                echo "üîé Target image: $TARGET_IMG"

                # Short template reflect check (now that tag exists)
                for i in $(seq 1 18); do
                  CUR_IMG=$(az containerapp show -n "$APP" -g "$RG" --query "properties.template.containers[0].image" -o tsv 2>/dev/null || echo "")
                  APP_STATE=$(az containerapp show -n "$APP" -g "$RG" --query "properties.provisioningState" -o tsv 2>/dev/null || echo "")
                  echo "Template check $i/18: image='$CUR_IMG' | app.provisioningState='$APP_STATE'"

                  [[ "$CUR_IMG" == "$TARGET_IMG" ]] && break
                  if [[ "$APP_STATE" == "Failed" ]]; then
                    echo "‚ö†Ô∏è App provisioningState=Failed; deploymentErrors:"
                    az containerapp show -n "$APP" -g "$RG" --query properties.deploymentErrors -o tsv || true
                  fi
                  sleep 5
                done

                TARGET_REV=""
                for i in $(seq 1 60); do
                  TARGET_REV=$(az containerapp revision list -n "$APP" -g "$RG" \
                    --query "[?properties.template.containers[0].image=='${TARGET_IMG}']|[0].name" -o tsv 2>/dev/null || echo "")
                  [[ -n "$TARGET_REV" ]] && { echo "‚úÖ Target revision: $TARGET_REV"; break; }
                  echo "‚è≥ Waiting for target revision ($i/60)‚Ä¶"; sleep 5
                done

                if [[ -z "$TARGET_REV" ]]; then
                  echo "‚ùå No revision found with image '$TARGET_IMG'. Revisions snapshot:"
                  az containerapp revision list -n "$APP" -g "$RG" -o table || true
                  exit 1
                fi

                MAX_TRIES=90
                for i in $(seq 1 $MAX_TRIES); do
                  REV_JSON=$(az containerapp revision show -n "$APP" -g "$RG" --revision "$TARGET_REV" -o json 2>/dev/null || echo "{}")
                  PROV=$(echo "$REV_JSON" | jq -r '.properties.provisioningState // empty')
                  HEALTH=$(echo "$REV_JSON" | jq -r '.properties.healthState // empty')
                  RUNSTATE=$(echo "$REV_JSON" | jq -r '.properties.runningState // empty')
                  echo "Revision $TARGET_REV ($i/$MAX_TRIES): provisioning=$PROV | health=$HEALTH | runningState=$RUNSTATE"

                  if [[ "$PROV" == "Succeeded" && "$HEALTH" == "Healthy" && "$RUNSTATE" =~ ^(Running|RunningAtMaxScale)$ ]]; then
                    echo "‚úÖ Deployment succeeded: $TARGET_REV is Healthy."
                    exit 0
                  fi

                  if [[ "$PROV" == "Failed" || "$HEALTH" =~ ^(Failed|Degraded)$ ]]; then
                    echo "‚ùå Revision indicates failure. System + console logs:"
                    az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --type system --tail 200 --format text || true
                    az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --tail 200 --format text || true
                    exit 1
                  fi
                  sleep 5
                done

                echo "‚ùå Timed out waiting for revision $TARGET_REV to become Healthy."
                az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --type system --tail 200 --format text || true
                az containerapp logs show -n "$APP" -g "$RG" --revision "$TARGET_REV" --tail 200 --format text || true
                exit 1